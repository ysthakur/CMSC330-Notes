# Data Representation

## Representing characters

- ASCII
- Unicode

## Representing unsigned integers

- Unsigned integers are >= 0
- Every bit position represents `2^i` (count `i` from the right, starting at 0).
  Those values are summed to get the integer's value.
- Using n bits, the numbers 0 to `2^n-1` can be represented

## Representing signed integers

- Use two's complement representation
- The leftmost bit represents the sign (0 for positive, 1 for negative)
- To get two's complement representation of a negative value, flip all the bits
  of the corresponding positive value and add 1
- Addition still works (ignore the overflow)
- Only one representation of 0 (all 0s)

## Representation of floats/doubles

Each number has 3 parts:

- A sign bit (s) (0 for positive, 1 for negative)
- A mantissa (m) representing a number between 0 and 1
  - Normalized into [1, 2]
- An exponent (e) designating position of decimal point

### IEEE 754 standard

- 32-bit is `float`
  - 1 sign bit
  - 8 bits exponent
  - 23 bits mantissa
- 64-bit is `double`
  - 1 sign bit
  - 11 bits exponent
  - 52 bits mantissa
- 128-bit (quad)
  - 1 sign bit
  - 15 bits exponent
  - 112 bits mantissa
  - Not commonly used

### Bias

- Needed to be able to represent both very large and very small numbers
- Bias value is `2^(# bits of biased exponent - 1) - 1`
- Real exponent = biased exponent - bias
- For single precision `float`s (32 bits):
  - The bias is `2^(8-1) - 1 = 127`
  - Can represent floating point numbers with real exponent from -127 to 128
